########################################
########################################
########################################
# Internal functions for federated AutoScore
# source("functions_federatedLR.R")
# # source("Federated AutoScore.R")
# source("./AutoScore-master/R/AutoScore.R")

######################################################
# reformat and write output of AutoScore_rank() to csv file
# rank: vector, output by AutoScore_rank()
# name: character, example: "imp1", "imp2",... assigned for each site
# rank: character, example: "rank1", "rank2".... assigned for each site accordingly
write_rank <- function(data, csv_name){
  var <- names(data) %>% as.vector()
  tbl <- as.data.frame(cbind(var,data))
  tbl$rank = c(1:length(data))
  colnames(tbl) <- c("var", "imp", "rank")
  
  write.csv(tbl, file = csv_name, row.names = F)
  print(sprintf("reformatted rank has been written into %s", csv_name))
}

######################################################
# get scores consist of integers from a coefficient 
transform_score <- function(vec, myrange = 100){
  # vec = vec[-1]
  c1 = range(vec)
  l = c1[2]- c1[1]
  c2 = vec * myrange/l
  return(round(c2))
}

######################################################
# transform score tbl to all positive, by adding a positive integer
transform_scoretbl <- function(vec){
  return(vec - min(vec))
}

######################################################
# get unified cut off for all sites
# read from cutoff.json 
# return unified cutoff for variables
get_uni_cut <- function(site_list, path = "cutoff.json"){
  cut_all <- vector(mode = "list", length = length(site_list))
  for(i in 1:length(site_list)){
  cutoff <- read_cutoff(site_list[i], path)
  cut_all[[i]] <- cutoff
  list_name <- names(cutoff)
  }
  # print(cut_all)
  cut_uni <- vector(mode = "list", length = length(list_name))
  # use loop to check if the length of cutoff are the same; add later
  for(i in 1:length(list_name)){
    N= length(cut_all[[1]][[i]])
    myvec <- rep(0,N)
     for(j in 1:length(cut_all)){
       if( typeof(cut_all[[j]][[i]]) == "character"){
       cut_uni[[i]] = "let_binary"
        break
       }
       else{
         # print(cut_all[[i]][[j]])
         myvec <- myvec + as.vector(cut_all[[j]][[i]])
       }
       cut_uni[[i]] = floor(myvec / length(cut_all)) 
     }
  }
  names(cut_uni) <- list_name
  
  # reorder cutoff to match the order of colnames()
  
  return(cut_uni)
}

######################################################
# new function to 
# transform continuous variable in df to categorical
# input: list read from cutoff.json
#        training data at local site (full)
#        variableList
transform_df <- function(dat, cutoff, variableList){
  var_cts = names(cutoff)
  var_other =  variableList[!variableList %in% var_cts]
  # print(varaibleList)
  # print(var_other)
  # colnames(dat)
  df_temp = dat[, var_cts]
  df = c()
  for(i in 1:length(var_cts)){
    if(typeof(cutoff[[i]]) == "character"){
      df  = cbind(df, df_temp[,i])
    }
    else{
    vec = cut(df_temp[,i], breaks = cutoff[[i]], include.lowest = T)
    df  = cbind(df,vec)
    }
  }
  colnames(df) = var_cts
  df  = cbind(df, dat[, var_other])
  head(df)
}


######################################################
# federated version of compute_score_table()
# input: 
#        max_score, 
#        coef_vec: the coefficient of global model
#        train_set_2: local training data after transformed
#        variable_list
# write score table to score.Json
compute_Fscore_table <- function(max_score=100, coef_vec, train_set_2, variable_list){
  # rounding for final scoring table "score_table"
  coef_vec_tmp <- round(coef_vec / min(coef_vec[-1]))
  score_table <- add_baseline(train_set_2, coef_vec_tmp)
  
  # normalization according to "max_score" and regenerate score_table
  total_max <- max_score
  total <- 0
  for (i in 1:length(variable_list))
    total <-
    total + max(score_table[grepl(variable_list[i], names(score_table))])
  score_table <- round(score_table / (total / total_max))
  return(score_table)
}




######################################################
# federated version of compute_auc_val()
# input: validation data at one site
#        sitenameL: sitename of training data  used to obtain scores
#        sitenameV: sitename of validation data
# output: roc object generated by pROC package

compute_Fauc <- function(validation_set, sitenameL, sitenameV){
  # get score table from score.json:
  score_table <- read_score(sitenameL)
  # use assign_score() to reformat validation set:
  
}




